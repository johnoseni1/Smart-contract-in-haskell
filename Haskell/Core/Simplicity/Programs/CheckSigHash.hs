{-# LANGUAGE RecordWildCards #-}
-- | The module builds a Simplicity expression that mimics the behavour of a @CHECKSIG@ operation for Bitcoin but with universal signature hash modes.
-- This uses Schnorr signature verification specified in "Simplicity.Programs.LibSecp256k1".
module Simplicity.Programs.CheckSigHash
  ( sigHash
  , checkSigHash, checkSigHash'
  -- * Types
  , Hash
  ) where

import Simplicity.Digest
import Simplicity.Functor
import qualified Simplicity.LibSecp256k1.Schnorr as Schnorr
import Simplicity.MerkleRoot
import Simplicity.Programs.Generic
import Simplicity.Programs.Sha256 hiding (Lib(Lib), lib)
import qualified Simplicity.Programs.Sha256 as Sha256
import Simplicity.Programs.LibSecp256k1 hiding (Lib(Lib), lib, mkLib)
import qualified Simplicity.Programs.LibSecp256k1 as LibSecp256k1
import Simplicity.Term.Core
import Simplicity.Ty
import Simplicity.Ty.Word

-- | Given a signature hash mode, compute a digest of the hash mode's 'commitmentRoot' and the hash mode's output.
-- This constitutes the message that is verified by the 'checkSigHash' Simplicity program.
-- The signature hash mode is 'disconnect'ed and is not commited by the 'commitmentRoot' of this expression.
sigHash :: (Core term, Delegate term) => Sha256.Lib term -- ^ "Simplicity.Programs.Sha256"
                                      -> term () Hash -- ^ signature hash mode
                                      -> term () Hash
sigHash Sha256.Lib{..} hashMode =
      (scribe iv &&& (disconnect iden hashMode) >>> hb)
  &&& scribe (toWord512 0x80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400)
  >>> hb
 where
  iv = toWord256 . integerHash256 . ivHash $ signatureTag
  hb = hashBlock

-- | Given a static public key, this Simplicity program asserts that the given signature is valid for the public key and the digest generated by
-- the given signature hash mode.
-- The signature hash mode is 'disconnect'ed and is not commited by the 'commitmentRoot' of this expression.
-- The signature is in a 'witness' combinator and is not commited by the 'commitmentRoot' of this expression.
checkSigHash :: (Assert term, Delegate term, Witness term) => Sha256.Lib term -- ^ "Simplicity.Programs.Sha256"
                                                           -> LibSecp256k1.Lib term -- ^ "Simplicity.Programs.LibSecp256k1"
                                                           -> term () Hash -- ^ signature hash mode
                                                           -> Schnorr.PubKey -> Schnorr.Sig -> term () ()
checkSigHash libSha256 libsecp256k1 hashMode (Schnorr.PubKey x) ~(Schnorr.Sig r s) =
   (scribe (toWord256 . toInteger $ x) &&& (sigHash libSha256 hashMode)) &&& (witness (toWord256 . toInteger $ r, toWord256 . toInteger $ s))
   >>> bip0340_verify libsecp256k1

-- | Given a static public key, this Simplicity program asserts that the given signature is valid for the public key and the digest generated by
-- the given signature hash mode.
-- The signature hash mode is 'disconnect'ed and is not commited by the 'commitmentRoot' of this expression.
-- The signature is in a 'witness' combinator and is not commited by the 'commitmentRoot' of this expression.
--
-- This program has its dependencies instantiated.
-- If you wish to use this expression in a more complex program use 'checkSigHash' in order to share dependencies.
checkSigHash' :: (Assert term, Delegate term, Witness term) => term () Hash -- ^ signature hash mode
                                                            -> Schnorr.PubKey -> Schnorr.Sig -> term () ()
checkSigHash' = checkSigHash libSha256 libSecp256k1
 where
  libSha256 = Sha256.lib
  libSecp256k1 = LibSecp256k1.mkLib libSha256
